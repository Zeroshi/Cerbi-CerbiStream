# Cerbi-CerbiStream SDK - v1.1 Update

**Repository:** `Cerbi-CerbiStream`  
**Location:** `C:\Users\thoma\source\repos\Zeroshi\Cerbi-CerbiStream`  
**Date:** 2026-02-03  
**Status:** ðŸ”´ Implementation Required

---

## Overview

The core .NET logging SDK. Updates required:
1. **TenantId from governance config** - Auto-generated during install, embedded in config
2. **Auto-detection** - Environment, InstanceId, AppVersion
3. **New fields** - ServiceName for microservices

---

## Current State Analysis

### Project Structure
```
Cerbi-CerbiStream/
â”œâ”€â”€ LoggingStandards/           # Main SDK project
â”‚   â”œâ”€â”€ CerbiStream.csproj
â”‚   â”œâ”€â”€ Classes/
â”‚   â”‚   â””â”€â”€ Logging.cs          # Main logging implementation
â”‚   â”œâ”€â”€ Configuration/
â”‚   â”‚   â””â”€â”€ CerbiStreamOptions.cs
â”‚   â””â”€â”€ Services/               # Need to add new services here
â”œâ”€â”€ CerbiStream--UnitTests/
â”œâ”€â”€ CerbiStream.IntegrationTests/
â””â”€â”€ BenchmarkSuite1/
```

---

## Required Changes

### 1. Update Package Reference

**File:** `LoggingStandards/CerbiStream.csproj`

```xml
<ItemGroup>
  <!-- Update to 1.1.0 -->
  <PackageReference Include="CerbiShield.Contracts" Version="1.1.0" />
</ItemGroup>
```

---

### 2. Create EnvironmentDetector (NEW FILE)

**File:** `LoggingStandards/Services/EnvironmentDetector.cs`

```csharp
using System;
using System.Reflection;

namespace CerbiStream.Services;

/// <summary>
/// Auto-detects runtime environment values.
/// All detection happens ONCE at startup via Lazy&lt;T&gt; - zero overhead per log.
/// </summary>
public static class EnvironmentDetector
{
    // Lazy ensures single computation, thread-safe
    private static readonly Lazy<string> _environment = new(DetectEnvironmentInternal);
    private static readonly Lazy<string> _instanceId = new(DetectInstanceIdInternal);
    private static readonly Lazy<string?> _appVersion = new(DetectAppVersionInternal);
    private static readonly Lazy<string?> _deploymentId = new(DetectDeploymentIdInternal);

    /// <summary>
    /// Deployment environment (Development/Staging/Production).
    /// Sources: ASPNETCORE_ENVIRONMENT â†’ DOTNET_ENVIRONMENT â†’ ENVIRONMENT â†’ "Unknown"
    /// </summary>
    public static string Environment => _environment.Value;

    /// <summary>
    /// Instance/pod/container identifier.
    /// Sources: HOSTNAME â†’ WEBSITE_INSTANCE_ID â†’ CONTAINER_APP_REPLICA_NAME â†’ MachineName
    /// </summary>
    public static string InstanceId => _instanceId.Value;

    /// <summary>
    /// Application version.
    /// Sources: APP_VERSION env â†’ Entry assembly version
    /// </summary>
    public static string? AppVersion => _appVersion.Value;

    /// <summary>
    /// Deployment/release identifier.
    /// Sources: DEPLOYMENT_ID â†’ BUILD_ID â†’ RELEASE_ID â†’ null
    /// </summary>
    public static string? DeploymentId => _deploymentId.Value;

    private static string DetectEnvironmentInternal()
    {
        return System.Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT")
            ?? System.Environment.GetEnvironmentVariable("DOTNET_ENVIRONMENT")
            ?? System.Environment.GetEnvironmentVariable("ENVIRONMENT")
            ?? "Unknown";
    }

    private static string DetectInstanceIdInternal()
    {
        // Kubernetes / Docker
        var hostname = System.Environment.GetEnvironmentVariable("HOSTNAME");
        if (!string.IsNullOrEmpty(hostname))
            return hostname;

        // Azure App Service
        var websiteInstance = System.Environment.GetEnvironmentVariable("WEBSITE_INSTANCE_ID");
        if (!string.IsNullOrEmpty(websiteInstance))
            return websiteInstance;

        // Azure Container Apps
        var containerAppReplica = System.Environment.GetEnvironmentVariable("CONTAINER_APP_REPLICA_NAME");
        if (!string.IsNullOrEmpty(containerAppReplica))
            return containerAppReplica;

        // AWS ECS
        var ecsTaskArn = System.Environment.GetEnvironmentVariable("ECS_CONTAINER_METADATA_URI");
        if (!string.IsNullOrEmpty(ecsTaskArn))
            return ExtractEcsTaskId(ecsTaskArn);

        // Fallback
        return System.Environment.MachineName;
    }

    private static string? DetectAppVersionInternal()
    {
        // CI/CD pipeline set
        var envVersion = System.Environment.GetEnvironmentVariable("APP_VERSION");
        if (!string.IsNullOrEmpty(envVersion))
            return envVersion;

        // Assembly version
        try
        {
            var assembly = Assembly.GetEntryAssembly();
            var version = assembly?.GetName().Version;
            if (version != null)
                return $"{version.Major}.{version.Minor}.{version.Build}";
        }
        catch
        {
            // Ignore reflection failures
        }

        return null;
    }

    private static string? DetectDeploymentIdInternal()
    {
        return System.Environment.GetEnvironmentVariable("DEPLOYMENT_ID")
            ?? System.Environment.GetEnvironmentVariable("BUILD_ID")
            ?? System.Environment.GetEnvironmentVariable("RELEASE_ID")
            ?? System.Environment.GetEnvironmentVariable("BUILD_BUILDID"); // Azure DevOps
    }

    private static string ExtractEcsTaskId(string metadataUri)
    {
        // ECS metadata URI contains task ID
        try
        {
            var parts = metadataUri.Split('/');
            return parts.Length > 0 ? parts[^1] : System.Environment.MachineName;
        }
        catch
        {
            return System.Environment.MachineName;
        }
    }
}
```

---

### 3. Create GovernanceConfigReader (NEW FILE)

**File:** `LoggingStandards/Services/GovernanceConfigReader.cs`

```csharp
using CerbiShield.Contracts.Governance;
using System;
using System.IO;
using System.Text.Json;

namespace CerbiStream.Services;

/// <summary>
/// Reads governance config from file or URL.
/// Config contains TenantId (from dashboard) so developers don't need to configure it.
/// </summary>
public class GovernanceConfigReader
{
    private readonly string _configPath;
    private GovernanceConfigDto? _cachedConfig;
    private DateTime _lastRead;
    private readonly TimeSpan _cacheDuration = TimeSpan.FromMinutes(5);
    
    private static readonly JsonSerializerOptions _jsonOptions = new()
    {
        PropertyNameCaseInsensitive = true,
        ReadCommentHandling = JsonCommentHandling.Skip
    };

    public GovernanceConfigReader(string? configPath = null)
    {
        _configPath = ResolveConfigPath(configPath);
    }

    /// <summary>
    /// Gets TenantId from governance config (embedded by dashboard during export).
    /// </summary>
    public string? GetTenantId()
    {
        return GetConfig()?.TenantId;
    }

    /// <summary>
    /// Gets the default profile name.
    /// </summary>
    public string GetDefaultProfile()
    {
        return GetConfig()?.DefaultProfile ?? "default";
    }

    /// <summary>
    /// Gets the full governance config.
    /// </summary>
    public GovernanceConfigDto? GetConfig()
    {
        // Return cached if fresh
        if (_cachedConfig != null && DateTime.UtcNow - _lastRead < _cacheDuration)
            return _cachedConfig;

        if (!File.Exists(_configPath))
        {
            Console.WriteLine($"[CerbiStream] Governance config not found at: {_configPath}");
            return null;
        }

        try
        {
            var json = File.ReadAllText(_configPath);
            _cachedConfig = JsonSerializer.Deserialize<GovernanceConfigDto>(json, _jsonOptions);
            _lastRead = DateTime.UtcNow;
            
            Console.WriteLine($"[CerbiStream] Loaded governance config. TenantId: {_cachedConfig?.TenantId}");
            return _cachedConfig;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[CerbiStream] Failed to read governance config: {ex.Message}");
            return null;
        }
    }

    /// <summary>
    /// Resolves config path from multiple sources.
    /// </summary>
    private static string ResolveConfigPath(string? explicitPath)
    {
        // 1. Explicit path
        if (!string.IsNullOrEmpty(explicitPath))
            return explicitPath;

        // 2. Environment variable
        var envPath = Environment.GetEnvironmentVariable("CERBI_GOVERNANCE_PATH");
        if (!string.IsNullOrEmpty(envPath))
            return envPath;

        // 3. Default locations (check in order)
        var defaultLocations = new[]
        {
            Path.Combine(AppContext.BaseDirectory, "cerbi_governance.json"),
            Path.Combine(AppContext.BaseDirectory, "config", "cerbi_governance.json"),
            Path.Combine(Directory.GetCurrentDirectory(), "cerbi_governance.json"),
            "cerbi_governance.json"
        };

        foreach (var location in defaultLocations)
        {
            if (File.Exists(location))
                return location;
        }

        // Return default (may not exist)
        return defaultLocations[0];
    }
}
```

---

### 4. Update CerbiStreamOptions

**File:** `LoggingStandards/Configuration/CerbiStreamOptions.cs`

Add new properties and resolution methods:

```csharp
using CerbiStream.Services;

namespace CerbiStream.Logging.Configuration;

public partial class CerbiStreamOptions
{
    // === IDENTITY FIELDS ===
    
    private string? _explicitTenantId;
    private string? _explicitEnvironment;
    private string? _explicitInstanceId;
    private string? _explicitAppVersion;
    private GovernanceConfigReader? _configReader;

    /// <summary>
    /// Application name. Required.
    /// </summary>
    public string? ApplicationName { get; private set; }

    /// <summary>
    /// Service name (for microservices). Optional.
    /// </summary>
    public string? ServiceName { get; private set; }

    // === FLUENT CONFIGURATION METHODS ===

    /// <summary>
    /// Sets TenantId explicitly. Overrides governance config.
    /// Most apps don't need this - TenantId comes from governance config.
    /// </summary>
    public CerbiStreamOptions WithTenantId(string tenantId)
    {
        _explicitTenantId = tenantId;
        return this;
    }

    /// <summary>
    /// Sets application name. Required.
    /// </summary>
    public CerbiStreamOptions WithAppName(string appName)
    {
        ApplicationName = appName;
        return this;
    }

    /// <summary>
    /// Sets application identity.
    /// </summary>
    public CerbiStreamOptions WithApplicationIdentity(string appName, string? environment = null)
    {
        ApplicationName = appName;
        _explicitEnvironment = environment;
        return this;
    }

    /// <summary>
    /// Sets service name (for microservices).
    /// </summary>
    public CerbiStreamOptions WithServiceName(string serviceName)
    {
        ServiceName = serviceName;
        return this;
    }

    /// <summary>
    /// Sets governance config path. TenantId is read from this file.
    /// </summary>
    public CerbiStreamOptions WithGovernanceConfig(string? configPath = null)
    {
        _configReader = new GovernanceConfigReader(configPath);
        return this;
    }

    /// <summary>
    /// Override environment (normally auto-detected).
    /// </summary>
    public CerbiStreamOptions WithEnvironment(string environment)
    {
        _explicitEnvironment = environment;
        return this;
    }

    /// <summary>
    /// Override instance ID (normally auto-detected).
    /// </summary>
    public CerbiStreamOptions WithInstanceId(string instanceId)
    {
        _explicitInstanceId = instanceId;
        return this;
    }

    /// <summary>
    /// Override app version (normally auto-detected).
    /// </summary>
    public CerbiStreamOptions WithAppVersion(string appVersion)
    {
        _explicitAppVersion = appVersion;
        return this;
    }

    // === RESOLUTION METHODS (used internally) ===

    /// <summary>
    /// Resolves TenantId with priority: Override â†’ Config â†’ EnvVar â†’ Error
    /// </summary>
    public string ResolveTenantId()
    {
        // 1. Developer override
        if (!string.IsNullOrEmpty(_explicitTenantId))
            return _explicitTenantId;

        // 2. Governance config (from dashboard)
        var configTenant = _configReader?.GetTenantId();
        if (!string.IsNullOrEmpty(configTenant))
            return configTenant;

        // 3. Environment variable
        var envTenant = Environment.GetEnvironmentVariable("CERBI_TENANT_ID");
        if (!string.IsNullOrEmpty(envTenant))
            return envTenant;

        // 4. Error - must have TenantId
        throw new InvalidOperationException(
            "TenantId not configured. Options:\n" +
            "1. Download cerbi_governance.json from dashboard (recommended)\n" +
            "2. Use .WithTenantId(\"your-tenant\")\n" +
            "3. Set CERBI_TENANT_ID environment variable");
    }

    /// <summary>
    /// Resolves Environment with priority: Override â†’ Auto-detect
    /// </summary>
    public string ResolveEnvironment()
    {
        return _explicitEnvironment ?? EnvironmentDetector.Environment;
    }

    /// <summary>
    /// Resolves InstanceId with priority: Override â†’ Auto-detect
    /// </summary>
    public string ResolveInstanceId()
    {
        return _explicitInstanceId ?? EnvironmentDetector.InstanceId;
    }

    /// <summary>
    /// Resolves AppVersion with priority: Override â†’ Auto-detect
    /// </summary>
    public string? ResolveAppVersion()
    {
        return _explicitAppVersion ?? EnvironmentDetector.AppVersion;
    }

    /// <summary>
    /// Resolves DeploymentId (auto-detect only)
    /// </summary>
    public string? ResolveDeploymentId()
    {
        return EnvironmentDetector.DeploymentId;
    }

    /// <summary>
    /// Resolves GovernanceProfile with priority: Override â†’ Config default â†’ "default"
    /// </summary>
    public string ResolveGovernanceProfile()
    {
        return GovernanceProfile
            ?? _configReader?.GetDefaultProfile()
            ?? "default";
    }
}
```

---

### 5. Create ScoringEventTransformer (NEW FILE)

**File:** `LoggingStandards/Services/ScoringEventTransformer.cs`

```csharp
using CerbiShield.Contracts;
using CerbiShield.Contracts.Scoring;
using CerbiStream.Logging.Configuration;
using System;
using System.Collections.Generic;
using System.Linq;

namespace CerbiStream.Services;

/// <summary>
/// Transforms log entries to ScoringEventDto format.
/// Score is NULL - Scoring API computes it using governance config.
/// </summary>
public static class ScoringEventTransformer
{
    public static ScoringEventDto Transform(
        object logEntry,
        string logId,
        CerbiStreamOptions options,
        IDictionary<string, object>? enrichedData = null)
    {
        var data = ExtractAsDictionary(logEntry, enrichedData);
        var violations = ExtractViolations(data);

        return new ScoringEventDto
        {
            SchemaVersion = ContractVersions.ScoringEventSchemaVersion,

            // Identity - resolved with fallback chains
            TenantId = options.ResolveTenantId(),
            AppName = options.ApplicationName ?? "unknown",
            ServiceName = options.ServiceName,
            Environment = options.ResolveEnvironment(),

            // Auto-detected
            Runtime = "dotnet",
            InstanceId = options.ResolveInstanceId(),
            AppVersion = options.ResolveAppVersion(),
            DeploymentId = options.ResolveDeploymentId(),

            // Log metadata
            LogId = logId,
            CorrelationId = ExtractString(data, "CorrelationId")
                ?? ExtractString(data, "RequestId")
                ?? ExtractString(data, "TraceId"),
            TimestampUtc = DateTime.UtcNow,
            LogLevel = ExtractString(data, "LogLevel") ?? "Information",

            // Governance
            GovernanceProfile = options.ResolveGovernanceProfile(),

            // Score is NULL - Scoring API computes it
            Score = null,

            // Violations with severities from governance config
            Violations = violations,

            GovernanceFlags = new GovernanceFlagsDto
            {
                GovernanceRelaxed = ExtractBool(data, "GovernanceRelaxed")
            },

            RawPayload = data
        };
    }

    private static List<ViolationDto> ExtractViolations(IDictionary<string, object> data)
    {
        var result = new List<ViolationDto>();

        if (!data.TryGetValue("GovernanceViolations", out var rawViolations) || rawViolations == null)
            return result;

        if (rawViolations is IEnumerable<object> enumerable)
        {
            foreach (var item in enumerable)
            {
                var violation = MapToViolationDto(item);
                if (violation != null)
                    result.Add(violation);
            }
        }

        return result;
    }

    private static ViolationDto? MapToViolationDto(object item)
    {
        if (item is IDictionary<string, object> dict)
        {
            return new ViolationDto
            {
                RuleId = ExtractString(dict, "RuleId"),
                Code = ExtractString(dict, "Code"),
                Field = ExtractString(dict, "Field"),
                Severity = ExtractString(dict, "Severity"),
                Message = ExtractString(dict, "Message")
            };
        }

        // Handle strongly-typed violation objects via reflection
        var type = item.GetType();
        if (type.Name.Contains("Violation"))
        {
            return new ViolationDto
            {
                RuleId = GetPropertyValue(item, "RuleId"),
                Code = GetPropertyValue(item, "Code"),
                Field = GetPropertyValue(item, "Field"),
                Severity = GetPropertyValue(item, "Severity"),
                Message = GetPropertyValue(item, "Message")
            };
        }

        return null;
    }

    private static string? GetPropertyValue(object obj, string propertyName)
    {
        return obj.GetType().GetProperty(propertyName)?.GetValue(obj)?.ToString();
    }

    private static IDictionary<string, object> ExtractAsDictionary(
        object logEntry,
        IDictionary<string, object>? enrichedData)
    {
        var result = new Dictionary<string, object>(StringComparer.OrdinalIgnoreCase);

        if (enrichedData != null)
        {
            foreach (var kvp in enrichedData)
                result[kvp.Key] = kvp.Value;
        }

        if (logEntry is IDictionary<string, object> dict)
        {
            foreach (var kvp in dict)
                result[kvp.Key] = kvp.Value;
        }
        else
        {
            foreach (var prop in logEntry.GetType().GetProperties())
            {
                try
                {
                    var value = prop.GetValue(logEntry);
                    if (value != null)
                        result[prop.Name] = value;
                }
                catch { }
            }
        }

        return result;
    }

    private static string? ExtractString(IDictionary<string, object> data, string key)
    {
        return data.TryGetValue(key, out var value) ? value?.ToString() : null;
    }

    private static bool ExtractBool(IDictionary<string, object> data, string key)
    {
        if (data.TryGetValue(key, out var value))
        {
            if (value is bool b) return b;
            if (bool.TryParse(value?.ToString(), out var parsed)) return parsed;
        }
        return false;
    }
}
```

---

### 6. Update Logging.cs

**File:** `LoggingStandards/Classes/Logging.cs`

Update SendLogAsync to use transformer:

```csharp
// Add using
using CerbiStream.Services;
using CerbiShield.Contracts.Scoring;

// Update SendLogAsync method
private async Task<bool> SendLogAsync(object logEntry, IDictionary<string, object>? enrichedData = null)
{
    try
    {
        var logId = Guid.NewGuid().ToString();

        // Transform to ScoringEventDto (Score is null - API computes it)
        var scoringEvent = ScoringEventTransformer.Transform(
            logEntry,
            logId,
            _options,
            enrichedData);

        string payload = _jsonConverter.ConvertMessageToJson(scoringEvent);

        // Encryption if enabled
        if (_options.EncryptionMode != IEncryptionTypeProvider.EncryptionType.None && _encryption.IsEnabled)
        {
            payload = _encryption.Encrypt(payload);
        }

        if (_options.ConsoleOutput)
        {
            Console.WriteLine($"[CerbiStream] Log {logId} | Tenant: {scoringEvent.TenantId} | App: {scoringEvent.AppName} | Env: {scoringEvent.Environment}");
        }

        if (_options.DisableQueueSending)
            return true;

        if (_options.EnableQueueRetries)
        {
            var policy = Policy
                .Handle<Exception>()
                .WaitAndRetryAsync(
                    _options.QueueRetryCount,
                    idx => TimeSpan.FromMilliseconds(_options.QueueRetryDelayMilliseconds));

            return await policy.ExecuteAsync(() => _queue.SendMessageAsync(payload, logId));
        }

        return await _queue.SendMessageAsync(payload, logId);
    }
    catch (Exception ex)
    {
        Console.WriteLine($"[CerbiStream] Logging failed: {ex.Message}");
        return false;
    }
}
```

---

## Developer Experience

### Before (Complex)
```csharp
builder.Logging.AddCerbiStream(options => options
    .WithTenantId("acme-corp")                    // Had to know this
    .WithApplicationIdentity("MyApp", "Production") // Had to set environment
    .WithGovernanceProfile("default")
    .WithQueue(...)
);
```

### After (Simple)
```csharp
// TenantId from config, environment auto-detected
builder.Logging.AddCerbiStream(options => options
    .WithAppName("MyApp")
    .WithServiceName("payment-api")              // Optional
    .WithGovernanceConfig()                       // TenantId embedded!
    .WithQueue("AzureServiceBus", connectionString, queueName)
);
```

---

## File Summary

| File | Action | Description |
|------|--------|-------------|
| `CerbiStream.csproj` | MODIFY | Update Contracts to 1.1.0 |
| `Services/EnvironmentDetector.cs` | CREATE | Auto-detection (Lazy cached) |
| `Services/GovernanceConfigReader.cs` | CREATE | Read TenantId from config |
| `Services/ScoringEventTransformer.cs` | CREATE | Transform to DTO |
| `Configuration/CerbiStreamOptions.cs` | MODIFY | Add resolution methods |
| `Classes/Logging.cs` | MODIFY | Use transformer |

---

## Build & Test

```bash
cd Cerbi-CerbiStream
dotnet restore
dotnet build
dotnet test
```
